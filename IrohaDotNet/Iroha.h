#pragma once

#include "msclr/marshal.h"
#include "KeyPair.h"
#pragma managed(push, off)
#include "Vendor/ed25519/src/ed25519.h"
#pragma managed(pop)

using namespace msclr::interop;
using namespace System;
using namespace System::Runtime::InteropServices;

namespace IrohaDotNet {

	/// <summary>
	/// This class generate keypair or create signature or verify the message.
	/// </summary>
	public ref class Iroha sealed
	{
	public:
		/// <summary>
		/// Create KeyPair for iroha client.
		/// </summary>
		/// <returns>keypair generated by Ed25519</returns>
		static KeyPair^ CreateKeyPair()
		{
			unsigned char seedbuf[32];
			unsigned char pubbuf[32];
			unsigned char prvbuf[64];

			ed25519_create_seed(seedbuf);
			ed25519_create_keypair(pubbuf, prvbuf, (const unsigned char *)seedbuf);

			array<unsigned char> ^publickey = gcnew array<unsigned char>(32);
			array<unsigned char> ^privatekey = gcnew array<unsigned char>(64);

			Marshal::Copy((IntPtr)pubbuf, publickey, 0, 32);
			Marshal::Copy((IntPtr)prvbuf, privatekey, 0, 64);

			KeyPair ^keyPair = gcnew KeyPair(
				Convert::ToBase64String(privatekey),
				Convert::ToBase64String(publickey));

			return keyPair;
		}

		/// <summary>
		/// Create signature for iroha.
		/// </summary>
		/// <param name="keyPair">keypair generated by Ed25519</param>
		/// <param name="message">message hashed by sha3</param>
		/// <returns>signature</returns>
		static String^ Sign(KeyPair ^keyPair, String ^message)
		{
			marshal_context ^context = gcnew marshal_context();
			unsigned char sigbuf[64];
			const char *msgbuf = context->marshal_as<const char *>(message);

			array<unsigned char> ^pubbuf = Convert::FromBase64String(keyPair->PublicKey);
			unsigned char *publickey = new unsigned char[pubbuf->Length];
			Marshal::Copy(pubbuf, 0, (IntPtr)publickey, pubbuf->Length);

			array<unsigned char> ^prvbuf = Convert::FromBase64String(keyPair->PrivateKey);
			unsigned char *privatekey = new unsigned char[prvbuf->Length];
			Marshal::Copy(prvbuf, 0, (IntPtr)privatekey, prvbuf->Length);

			ed25519_sign(sigbuf, (const unsigned char *)msgbuf, strlen(msgbuf), publickey, privatekey);

			array<unsigned char> ^signature = gcnew array<unsigned char>(64);
			Marshal::Copy((IntPtr)sigbuf, signature, 0, signature->Length);
			String ^result = Convert::ToBase64String(signature);

			delete privatekey;
			delete publickey;
			delete context;

			return result;
		}

		/// <summary>
		/// Check the message by signature.
		/// </summary>
		/// <param name="publicKey">ed25519 public key (encoded by base64)</param>
		/// <param name="signature">signature (encoded by base64)</param>
		/// <param name="message">target message</param>
		/// <returns>true if the correct message</returns>
		static bool Verify(String ^publicKey, String ^signature, String ^message)
		{
			marshal_context ^context = gcnew marshal_context();
			const char *msgbuf = context->marshal_as<const char *>(message);

			array<unsigned char> ^sigbuf = Convert::FromBase64String(signature);
			unsigned char *sig = new unsigned char[sigbuf->Length];
			Marshal::Copy(sigbuf, 0, (IntPtr)sig, sigbuf->Length);

			array<unsigned char> ^pubbuf = Convert::FromBase64String(publicKey);
			unsigned char *publickey = new unsigned char[pubbuf->Length];
			Marshal::Copy(pubbuf, 0, (IntPtr)publickey, pubbuf->Length);

			int result = ed25519_verify(sig, (const unsigned char *)msgbuf, strlen(msgbuf), publickey);

			delete publickey;
			delete sig;
			delete context;

			return result;
		}
	};
}
